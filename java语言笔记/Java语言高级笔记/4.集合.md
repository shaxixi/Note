[toc]

# Java进阶——集合

数组 VS 集合

1. 集合、数组都是对多个数据进行存储操作的结构，简称Java容器。

   说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中）

2. 数组在存储多个数据方面的特点：

​	\> 一旦初始化以后，其长度就确定了。

​	\> 数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。
​		比如：String[] arr;int[] arr1;Object[] arr2;

3. 数组在存储多个数据方面的缺点：

   \> 一旦初始化以后，其长度就不可修改。

   \> 数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。

   \> 获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用

   \> 数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。



集合框架

* Collection接口：单列集合，用来存储一个一个的对象
  * List接口：存储有序的、可重复的数据。  -->“动态”数组
    * 实现类：ArrayList、LinkedList、Vector
  * Set接口：存储无序的、不可重复的数据   -->高中讲的“集合”
    * 实现类：HashSet、LinkedHashSet、TreeSet

* Map接口：双列集合，用来存储一对(key - value)一对的数据   -->高中函数：y = f(x)
  * 实现类：HashMap、LinkedHashMap、TreeMap、Hashtable、Properties



## 集合使用场景

![image-20210516013525399](E:\软工\typora笔记\java语言笔记\Java语言高级笔记\4.集合.assets\image-20210516013525399.png)



## Collection接口中的方法的使用

> add(Object e)	将元素e添加到集合coll中
>
> size()	获取添加的元素的个数
>
> addAll(Collection coll1)	将coll1集合中的元素添加到当前的集合中
>
> clear()	清空集合元素
>
> isEmpty()	判断当前集合是否为空
>
> contains(Object obj)	判断当前集合中是否包含obj
>
> containsAll(Collection coll1)	判断形参coll1中的所有元素是否都存在于当前集合中
>
> remove(Object obj)	从当前集合中移除obj元素。
>
> removeAll(Collection coll1)	差集：从当前集合中移除coll1中所有的元素。
>
> retainAll(Collection coll1)	交集：获取当前集合和coll1集合的交集，并返回给当前集合
>
> equals(Object obj)	要想返回true，需要当前集合和形参集合的元素都相同。
>
> hashCode():返回当前对象的哈希值
>
> 集合 --->数组	toArray()	
>
> 数组 --->集合	调用Arrays类的静态方法asList()
>
> iterator()	返回Iterator接口的实例，用于遍历集合元素。

```java
public class CollectionTest {
    public void test(){
        Collection coll = new ArrayList();

        //add(Object e):将元素e添加到集合coll中
        coll.add("AA");
        coll.add("BB");
        coll.add(123);//自动装箱
        coll.add(new Date());

        //size():获取添加的元素的个数
        System.out.println(coll.size());//4

        //addAll(Collection coll1):将coll1集合中的元素添加到当前的集合中
        Collection coll1 = new ArrayList();
        coll1.add(456);
        coll1.add("CC");
        coll.addAll(coll1);

        System.out.println(coll.size());//6
        System.out.println(coll);

        //clear():清空集合元素
        coll.clear();

        //isEmpty():判断当前集合是否为空
        System.out.println(coll.isEmpty());
    }

    public void test1(){
        Collection coll = new ArrayList();
        coll.add(123);
        coll.add(456);
        coll.add(new Person("Jerry",20));
        coll.add(new String("Tom"));
        coll.add(false);

        //contains(Object obj):判断当前集合中是否包含obj
        //我们在判断时会调用obj对象所在类的equals()。
        boolean contains = coll.contains(123);
        System.out.println(contains);
        System.out.println(coll.contains(new String("Tom")));
        System.out.println(coll.contains(p));//true
        System.out.println(coll.contains(new Person("Jerry",20)));//false -->true（在自定义类中没有重写equals()，则equals()比较的是地址值；所以重写equals() 使其比较的是内容值）

        //containsAll(Collection coll1):判断形参coll1中的所有元素是否都存在于当前集合中。
        Collection coll1 = Arrays.asList(123,4567);
        System.out.println(coll.containsAll(coll1));
    }

    public void test2(){
        Collection coll = new ArrayList();
        coll.add(123);
        coll.add(456);
        coll.add(new Person("Jerry",20));
        coll.add(new String("Tom"));
        coll.add(false);

        //remove(Object obj):从当前集合中移除obj元素。
        coll.remove(1234);
        System.out.println(coll);

        coll.remove(new Person("Jerry",20));
        System.out.println(coll);

        //removeAll(Collection coll1):差集：从当前集合中移除coll1中所有的元素。
        Collection coll1 = Arrays.asList(123,456);
        coll.removeAll(coll1);
        System.out.println(coll);
    }

    public void test3(){
        Collection coll = new ArrayList();
        coll.add(123);
        coll.add(456);
        coll.add(new Person("Jerry",20));
        coll.add(new String("Tom"));
        coll.add(false);

        //retainAll(Collection coll1):交集：获取当前集合和coll1集合的交集，并返回给当前集合
        Collection coll1 = Arrays.asList(123,456,789);
        coll.retainAll(coll1);
        System.out.println(coll);

        //equals(Object obj):要想返回true，需要当前集合和形参集合的元素都相同。
        Collection coll1 = new ArrayList();
        coll1.add(456);
        coll1.add(123);
        coll1.add(new Person("Jerry",20));
        coll1.add(new String("Tom"));
        coll1.add(false);
        System.out.println(coll.equals(coll1));
    }

    public void test4(){
        Collection coll = new ArrayList();
        coll.add(123);
        coll.add(456);
        coll.add(new Person("Jerry",20));
        coll.add(new String("Tom"));
        coll.add(false);

        //hashCode():返回当前对象的哈希值
        System.out.println(coll.hashCode());

        //集合 --->数组：toArray()
        Object[] arr = coll.toArray();
        for(int i = 0;i < arr.length;i++){
            System.out.println(arr[i]);
        }

        //拓展：数组 --->集合:调用Arrays类的静态方法asList()
        List<String> list = Arrays.asList(new String[]{"AA", "BB", "CC"});
        System.out.println(list);

        List arr1 = Arrays.asList(new int[]{123, 456});
        System.out.println(arr1.size());//1

        List arr2 = Arrays.asList(new Integer[]{123, 456});
        System.out.println(arr2.size());//2

        //iterator():返回Iterator接口的实例，用于遍历集合元素。放在IteratorTest.java中测试

    }
}

public class Person {
    private String name;
    private int age;

    public Person() { }
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() { return name;}
    public void setName(String name) { this.name = name; }
    public int getAge() { return age;}
    public void setAge(int age) {this.age = age;}

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        System.out.println("Person equals()....");
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age &&
                Objects.equals(name, person.name);
    }
}
```



#### 迭代器Iterator接口

集合元素的遍历操作，使用迭代器Iterator接口

1. 内部的方法：hasNext() 和  next()

2. 集合对象每次调用iterator()方法都得到一个全新的迭代器对象，

   默认游标都在集合的第一个元素之前。

3. 内部定义了remove(),可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove()

   ~~~java
   public class IteratorTest {
       public void test1(){
           Collection coll = new ArrayList();
           coll.add(123);
           coll.add(456);
           coll.add(new Person("Jerry",20));
           coll.add(new String("Tom"));
           coll.add(false);
   
           Iterator iterator = coll.iterator();
           //方式一：
           System.out.println(iterator.next());
           System.out.println(iterator.next());
           System.out.println(iterator.next());
           System.out.println(iterator.next());
           System.out.println(iterator.next());
           //报异常：NoSuchElementException
           System.out.println(iterator.next());
   
           //方式二：不推荐
           for(int i = 0;i < coll.size();i++){
               System.out.println(iterator.next());
           }
   
           //方式三：推荐
           //hasNext():判断是否还有下一个元素
           while(iterator.hasNext()){
               //next():①指针下移 ②将下移以后集合位置上的元素返回
               System.out.println(iterator.next());
           }
       }
   
       public void test3(){
           Collection coll = new ArrayList();
           coll.add(123);
           coll.add(456);
           coll.add(new Person("Jerry",20));
           coll.add(new String("Tom"));
           coll.add(false);
   
           // Iterator中的remove()；删除集合中"Tom"
           Iterator iterator = coll.iterator();
           while (iterator.hasNext()){
               iterator.remove(); //错误，初始位置在第一个元素之前
               Object obj = iterator.next();
               if("Tom".equals(obj)){
                   iterator.remove();
                   iterator.remove(); //错误，remove() 调用后指针仍指向remove的那个位置，并没有向下移
               }
   
           }
           //遍历集合
           iterator = coll.iterator();
           while (iterator.hasNext()){
               System.out.println(iterator.next());
           }
       }
   }
   
   public class Person {
   	//和上面的代码块内容一样，忽略
   }
   ~~~

注意：
		\> 集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。

​		\> Iterator中的remove()；如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，再调用remove都会报IllegalStateException。



#### jdk 5.0 新增了foreach循环

用于遍历集合、数组

```java
public class ForTest {
	public void test1(){
        Collection coll = new ArrayList();
        coll.add(123);
        coll.add(456);
        coll.add(new Person("Jerry",20));
        coll.add(new String("Tom"));
        coll.add(false);

        //for(集合元素的类型 局部变量 : 集合对象)
        //内部仍然调用了迭代器。
        for(Object obj : coll){
            System.out.println(obj);
        }
    }

    public void test2(){
        int[] arr = new int[]{1,2,3,4,5,6};
        //for(数组元素的类型 局部变量 : 数组对象)
        for(int i : arr){
            System.out.println(i);
        }
    }
    
    public void test3(){
		int a[][] = new int[3][4];
		for(int i[] : a)
			for(int j: i)System.out.print(j);        
    }
}

public class Person {
	//和上面的代码块内容一样，忽略
}
```



### List接口框架


* Collection接口：单列集合，用来存储一个一个的对象

  *    List接口：存储有序的、可重复的数据。  -->“动态”数组,替换原有的数组

       *    ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储
       *    LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储
       *    Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储

* List接口中的常用方法

  > void add(int index, Object ele)	在index位置插入ele元素
  > boolean addAll(int index, Collection eles)	从index位置开始将eles中的所有元素添加进来
  > Object get(int index)	获取指定index位置的元素
  > int indexOf(Object obj)	返回obj在集合中首次出现的位置
  > int lastIndexOf(Object obj)	返回obj在当前集合中末次出现的位置
  > Object remove(int index)	移除指定index位置的元素，并返回此元素
  > Object set(int index, Object ele)	设置指定index位置的元素为ele
  > List subList(int fromIndex, int toIndex)	返回从fromIndex到toIndex位置的子集合

  ~~~java
  public class ListTest {
  	public void test1(){
          ArrayList list = new ArrayList();
          list.add(123);
          list.add(456);
          list.add("AA");
          list.add(new Person("Tom",12));
          list.add(456);
          
          //boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来
          List list1 = Arrays.asList(1, 2, 3);
          list.addAll(list1); //list1中的每一个对象增加到list中
          list.add(list1); //list1中所有对象作为一个对象增加到list中
          System.out.println(list.size());   
          
          //int indexOf(Object obj):返回obj在集合中首次出现的位置。如果不存在，返回-1.
          int index = list.indexOf(4567);
          System.out.println(index);        
          
          //int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置。如果不存在，返回-1.
          System.out.println(list.lastIndexOf(456));
          
          //List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的左闭右开区间的子集合
          List subList = list.subList(2, 4);
          System.out.println(subList);
          System.out.println(list);
      } 
  }
  
  public class Person {
  	//和上面的代码块内容一样，忽略
  }
  ~~~

  **常用方法**
  	增：add(Object obj)
  	删：remove(int index) / remove(Object obj)
  	改：set(int index, Object ele)
  	查：get(int index)
  	插：add(int index, Object ele)
  	长度：size()
  	遍历：① Iterator迭代器方式
   			  ② 增强for循环
   			  ③ 普通的循环

  ~~~java
  public class ListTest {
  	public void test1(){
          ArrayList list = new ArrayList();
          //增：add(Object obj)
          list.add(123);
          list.add(456);
          list.add("AA");
          list.add(new Person("Tom",12));
          list.add(456);
          
          //Object remove(int index):移除指定index位置的元素，并返回此元素
          Object obj = list.remove(0);
          System.out.println(obj);
          System.out.println(list);
          
          //Object set(int index, Object ele):设置指定index位置的元素为ele
          list.set(1,"CC");
          System.out.println(list);        
          
          //Object get(int index):获取指定index位置的元素
          System.out.println(list.get(0));      
         
          //void add(int index, Object ele):在index位置插入ele元素
          list.add(1,"BB");
          System.out.println(list);  
          
          //长度：size()
          System.out.println(list.size());
          
  		//遍历
          //方式一：Iterator迭代器方式
          Iterator iterator = list.iterator();
          while(iterator.hasNext()){
              System.out.println(iterator.next());
          }
  
          //方式二：增强for循环
          for(Object obj : list){
              System.out.println(obj);
          }
  
          //方式三：普通for循环
          for(int i = 0;i < list.size();i++){
              System.out.println(list.get(i));
          }
      }
  
  public class Person {
  	//和上面的代码块内容一样，忽略
  }
  ~~~

  

#### ArrayList的源码分析


* jdk 7情况下

  ~~~java
  ArrayList list = new ArrayList(); //底层创建了长度是10的Object[]数组elementData
  list.add(123);	//elementData[0] = new Integer(123);
  ...
  list.add(11);	//如果此次的添加导致底层elementData数组容量不够，则扩容。
  
  //默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。
  ~~~

  结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)

* jdk 8中ArrayList的变化

  ~~~java
  ArrayList list = new ArrayList();//底层Object[] elementData初始化为{}.并没有创建长度为10的数组
  list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]
  ...
      
  //后续的添加和扩容操作与jdk 7 无异。
  ~~~

  小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。

#### LinkedList的源码分析

~~~java
LinkedList list = new LinkedList(); //内部声明了Node类型的first和last属性，默认值为null
list.add(123);//将123封装到Node中，创建了Node对象。

//其中，Node定义为：体现了LinkedList的双向链表的说法
private static class Node<E> {
       E item;
       Node<E> next;
       Node<E> prev;

       Node(Node<E> prev, E element, Node<E> next) {
       this.item = element;
       this.next = next;
       this.prev = prev;
       }
}
~~~



#### Vector的源码分析

​	\> jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。

​	\> 在扩容方面，默认扩容为原来的数组长度的2倍。



### Set接口的框架


* Collection接口：单列集合，用来存储一个一个的对象

  * Set接口：存储无序的、不可重复的数据   -->高中讲的“集合”

    *              HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值
    *              LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历对于频繁的遍历操作，LinkedHashSet效率高于HashSet.
    *              TreeSet：可以按照添加对象的指定属性，进行排序。
* 注意：
  1. Set接口中没有额外定义新的方法，使用的都是Collection中声明过的方法。
  2. 向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()
  3. 重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码；重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。



#### HashSet

* 添加元素的过程：

  1. 我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，
  2. 此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断数组此位置上是否已经有元素：
     \> 如果此位置上没有其他元素，则元素a添加成功。 --->情况1
     \> 如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值【不同的对象可能计算出来的哈希值是一样的】：
             \> 如果hash值不相同，则元素a添加成功。--->情况2
             \> 如果hash值相同，进而需要调用元素a所在类的equals()方法：
                       \> equals()返回true,元素a添加失败
                       \> equals()返回false,则元素a添加成功。--->情况3

  ![image-20210516015320908](E:\软工\typora笔记\java语言笔记\Java语言高级笔记\4.集合.assets\image-20210516015320908.png)

  **注意：**

  1. 对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。
  2. jdk 7 :元素a放到数组中，指向原来的元素。【头插法】
     jdk 8 :原来的元素在数组中，指向元素a。【尾插法】
     总结：七上八下

* HashSet底层：数组+链表的结构。


~~~java
public class SetTest {
	public void test1(){
        Set set = new HashSet();
        set.add(456);
        set.add(123);
        set.add(123);
        set.add("AA");
        set.add("CC");
        set.add(new User("Tom",12));
        
        //不可重复性：保证添加的元素按照equals()判断时，不能返回true.即：相同的元素只能添加一个。
        set.add(new User("Tom",12)); //没有进入集合
        set.add(129);

        //无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。
        Iterator iterator = set.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next()); //输出的顺序和输入的顺序不一致
        }
    }
}

public class User implements Comparable{
    private String name;
    private int age;

    public User() {}
    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {return name;}
    public void setName(String name) {this.name = name;}

    public int getAge() {return age; }

    public void setAge(int age) {this.age = age;}

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    //向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()
    @Override
    public boolean equals(Object o) {
        System.out.println("User equals()....");
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        User user = (User) o;

        if (age != user.age) return false;
        return name != null ? name.equals(user.name) : user.name == null;
    }

    @Override
    public int hashCode() { //return name.hashCode() + age;
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + age;
        return result;
    }
}
~~~



#### LinkedHashSet

* LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。
  优点：对于频繁的遍历操作，LinkedHashSet效率高于HashSet

  【LinkedHashSet底层：链表 +链表的结构。】
  ![image-20210516015341569](E:\软工\typora笔记\java语言笔记\Java语言高级笔记\4.集合.assets\image-20210516015341569.png)
  
  ~~~java
  public class SetTest {
  	public void test2(){
          Set set = new LinkedHashSet();
          set.add(456);
          set.add(123);
          set.add(123);
          set.add("AA");
          set.add("CC");
          set.add(129);
  
          Iterator iterator = set.iterator();
          while(iterator.hasNext()){
              System.out.println(iterator.next());//输出的顺序和输入的顺序一致，链式表仍是无序的
          }
      }
  }
  ~~~



#### TreeSet

1. 向TreeSet中添加的数据，要求是相同类的对象。

2. 两种排序方式：自然排序（实现Comparable接口） 和 定制排序（Comparator）

   \> 自然排序中，比较两个对象是否相同的标准为：compareTo()返回0.不再是equals().

   ~~~java
   public class TreeSetTest {
   	public void test1(){
           TreeSet set = new TreeSet();
   
           //失败：不能添加不同类的对象
           set.add(123);
           set.add(456);
           set.add("AA");
           set.add(new User("Tom",12));
   
           //正确：
           set.add(new User("Tom",12));
           set.add(new User("Jerry",32));
           set.add(new User("Jim",2));
           set.add(new User("Mike",65));
           set.add(new User("Jack",33));
           set.add(new User("Jack",56));
   
   
           Iterator iterator = set.iterator();
           while(iterator.hasNext()){
               System.out.println(iterator.next());
           }
       }
   }
   
   public class User{
       private String name;
       private int age;
   
       public User() {}
       public User(String name, int age) {
           this.name = name;
           this.age = age;
       }
   
       public String getName() {return name;}
       public void setName(String name) {this.name = name;}
   
       public int getAge() {return age; }
   
       public void setAge(int age) {this.age = age;}
   
       @Override
       public String toString() {
           return "User{" +
                   "name='" + name + '\'' +
                   ", age=" + age +
                   '}';
       }
   
       //向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()
       @Override
       public boolean equals(Object o) {
           System.out.println("User equals()....");
           if (this == o) return true;
           if (o == null || getClass() != o.getClass()) return false;
   
           User user = (User) o;
   
           if (age != user.age) return false;
           return name != null ? name.equals(user.name) : user.name == null;
       }
   
       @Override
       public int hashCode() { //return name.hashCode() + age;
           int result = name != null ? name.hashCode() : 0;
           result = 31 * result + age;
           return result;
       }
   
       //按照姓名从大到小排列,年龄从小到大排列
       @Override
       public int compareTo(Object o) {
           if(o instanceof User){
               User user = (User)o;
   //            return -this.name.compareTo(user.name);
               int compare = -this.name.compareTo(user.name);
               if(compare != 0){
                   return compare;
               }else{
                   return Integer.compare(this.age,user.age);
               }
           }else{
               throw new RuntimeException("输入的类型不匹配");
           }
       }
   }
   ~~~

   

   \> 定制排序中，比较两个对象是否相同的标准为：compare()返回0.不再是equals().

   ~~~java
   public class TreeSetTest {
   	public void test2(){
           Comparator com = new Comparator() {
               //按照年龄从小到大排列
               @Override
               public int compare(Object o1, Object o2) {
                   if(o1 instanceof User && o2 instanceof User){
                       User u1 = (User)o1;
                       User u2 = (User)o2;
                       return Integer.compare(u1.getAge(),u2.getAge());
                   }else{
                       throw new RuntimeException("输入的数据类型不匹配");
                   }
               }
           };
   		
           TreeSet set = new TreeSet(com); //排序方式 com
           set.add(new User("Tom",12));
           set.add(new User("Jerry",32));
           set.add(new User("Jim",2));
           set.add(new User("Mike",65));
           set.add(new User("Mary",33));
           set.add(new User("Jack",33));
           set.add(new User("Jack",56));
   
           Iterator iterator = set.iterator();
           while(iterator.hasNext()){
               System.out.println(iterator.next());
           }
       }
   }
   
   public class User{
   	//和上上面代码一样，忽略
   }
   ~~~

   

## Map接口

  * Map的实现类的结构：

    \> Map:双列数据，存储key-value对的数据   ---类似于高中的函数：y = f(x)

    ​		\>> HashMap:作为Map的主要实现类；线程不安全的，效率高；**存储null的key和value**

    ​				\>>> LinkedHashMap:保证在遍历map元素时，可以按照添加的顺序实现遍历。

    ​		\>> TreeMap:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序底层使用红黑树

    ​		\>> Hashtable:作为古老的实现类；线程安全的，效率低；**不能存储null的key和value**

    ​				\>>> Properties:常用来处理配置文件。key和value都是String类型


* Map结构的理解：

  \> Map中的**key**: 无序的、不可重复的，使用Set存储所有的key  ---> key所在的类要重写equals()和hashCode() （以HashMap为例）

  \> Map中的**value**: 无序的、可重复的，使用Collection存储所有的value --->value所在的类要重写equals()

  \> 一个键值对：key-value构成了一个Entry对象。

  \> Map中的**entry**:无序的、不可重复的，使用Set存储所有的entry

* Map中定义的方法
  
  > 添加、删除、修改操作：
  > Object put(Object key,Object value)	将指定key-value添加到(或修改)当前map对象中
  > void putAll(Map m)	将m中的所有key-value对存放到当前map中
  > Object remove(Object key)	移除指定key的key-value对，并返回value
  > void clear()	清空当前map中的所有数据
  >
  > 元素查询的操作：
  > Object get(Object key)	获取指定key对应的value
  > boolean containsKey(Object key)	是否包含指定的key
  > boolean containsValue(Object value)	是否包含指定的value
  > int size()	返回map中key-value对的个数
  > boolean isEmpty()	判断当前map是否为空
  > boolean equals(Object obj)	判断当前map和参数对象obj是否相等
  >
  > 元视图操作的方法：
  > Set keySet()	返回所有key构成的Set集合
  > Collection values()	返回所有value构成的Collection集合
  > Set entrySet()	返回所有key-value对构成的Set集合
  
  ~~~java
  public void test3(){
      Map map = new HashMap();
      map.put("AA",123);
      map.put(45,123);
      map.put("BB",56);
      System.out.println(map);
  
      //void putAll(Map m)
      Map map1 = new HashMap();
      map1.put("CC",123);
      map1.put("DD",123);
      map.putAll(map1);
      System.out.println(map);
  
      //clear()
      map.clear();//与map = null操作不同
      System.out.println(map.size());
      System.out.println(map);
  
      //containsKey(Object key)
      boolean isExist = map.containsKey("BB");
      System.out.println(isExist);  
  
      //boolean containsValue(Object value)
      isExist = map.containsValue(123);
      System.out.println(isExist);
  
      //boolean isEmpty()
      System.out.println(map.isEmpty());        
  }
  ~~~
  
  **常用方法：**
  
  ​	添加：put(Object key,Object value)
  ​	删除：remove(Object key)
  ​	修改：put(Object key,Object value)
  ​	查询：get(Object key)
  ​	长度：size()
  ​	遍历：keySet() / values() / entrySet()
  
  ~~~java
  public void test3(){
      Map map = new HashMap();
  
      //添加：put(Object key,Object value)
      map.put("AA",123);
      map.put(45,123);
      map.put("BB",56);
  
      //删除：remove(Object key)
      Object value = map.remove("CC");
      System.out.println(value);
      System.out.println(map);
  
      //修改：put(Object key,Object value)
      map.put("AA",87);
      System.out.println(map);
  
      //查询：get(Object key)
      System.out.println(map.get(45));     
  
      //长度：size()
      System.out.println(map.size());
  }
  
  public void test5(){
      Map map = new HashMap();
      map.put("AA",123);
      map.put(45,1234);
      map.put("BB",56);
  
      //遍历所有的key集：keySet()
      Set set = map.keySet();
      Iterator iterator = set.iterator();
      while(iterator.hasNext()){
          System.out.println(iterator.next());
      }
      System.out.println();
  
      //遍历所有的value集：values()
      Collection values = map.values();
      for(Object obj : values){
          System.out.println(obj);
      }
      System.out.println();
  
      //遍历所有的key-value        
      //方式一：entrySet()
      Set entrySet = map.entrySet();
      Iterator iterator1 = entrySet.iterator();
      while (iterator1.hasNext()){
          Object obj = iterator1.next();
          //entrySet集合中的元素都是entry
          Map.Entry entry = (Map.Entry) obj;
          System.out.println(entry.getKey() + "---->" + entry.getValue());
      }
      System.out.println();
  
      //方式二：
      Set keySet = map.keySet();
      Iterator iterator2 = keySet.iterator();
      while(iterator2.hasNext()){
          Object key = iterator2.next();
          Object value = map.get(key);
          System.out.println(key + "=====" + value);
      }
  }
  ~~~
  
  

#### HashMap的底层实现原理

* 以jdk7为例说明

  ~~~java
  HashMap map = new HashMap()	//在实例化以后，底层创建了长度是16的一维数组Entry[] table。
      
  //...可能已经执行过多次put...
  map.put(key1,value1)  
  /*	1. 首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。
  	2. 如果此位置上的数据为空，此时的key1-value1添加成功。 ----情况1
  	3. 如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据的哈希值：
  		1）如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。----情况2
  		2）如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：
  			① 如果equals()返回false:此时key1-value1添加成功。----情况3
  			② 如果equals()返回true:使用value1替换value2。
  		补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。
  
  	在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。
  ~~~

  ![image-20210516015603665](E:\软工\typora笔记\java语言笔记\Java语言高级笔记\4.集合.assets\image-20210516015603665.png)

* jdk8 相较于jdk7在底层实现方面的不同：

  1. new HashMap():底层没有创建一个长度为16的数组

  2. jdk 8底层的数组是：Node[],而非Entry[]

  3. 首次调用put()方法时，底层创建长度为16的数组

  4. jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。

     \> 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）
     \> 当数组的某一个索引位置上的元素以链表形式存在的数据个数 > 8 且 当前数组的长度 > 64时，此时此索引位置上的所数据改为使用红黑树存储。

  ![image-20210516015612510](E:\软工\typora笔记\java语言笔记\Java语言高级笔记\4.集合.assets\image-20210516015612510.png)

  

* HashMap源码中的重要常量

  DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16

  DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75

  threshold：扩容的临界值，=容量*填充因子：16 * 0.75 => 12

  TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8

  MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64

  

* 负载因子值
  \> 负载因子的大小决定了HashMap的数据密度。 
  \> 负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长, 造成查询或插入时的比较次数增多，性能会下降。 
  \> 负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的 几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性 能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建 议初始化预设大一点的空间。 
  \> 按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此 时平均检索长度接近于常数

#####  LinkedHashMap的底层实现原理（了解）

* 源码中：
  在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。对于频繁的遍历操作，此类执行效率高于HashMap。
  
  ~~~java
  static class Entry<K,V> extends HashMap.Node<K,V> {
       Entry<K,V> before, after;//能够记录添加的元素的先后顺序
       Entry(int hash, K key, V value, Node<K,V> next) {
          super(hash, key, value, next);
       }
   }
  ~~~
  
  

#### TreeMap

* 向TreeMap中添加key-value，要求key必须是由同一个类创建的对象
  因为要按照key进行排序：自然排序 、定制排序

* 自然排序

  ~~~java
  public class TreeMapTest {
      //自然排序
      @Test
      public void test1(){
          TreeMap map = new TreeMap();
          User u1 = new User("Tom",23);
          User u2 = new User("Jerry",32);
          User u3 = new User("Jack",20);
          User u4 = new User("Rose",18);
  
          map.put(u1,98);
          map.put(u2,89);
          map.put(u3,76);
          map.put(u4,100);
  
          Set entrySet = map.entrySet();
          Iterator iterator1 = entrySet.iterator();
          while (iterator1.hasNext()){
              Object obj = iterator1.next();
              Map.Entry entry = (Map.Entry) obj;
              System.out.println(entry.getKey() + "---->" + entry.getValue());
          }
      }
  }
  
  public class User implements Comparable{
      //和上面的一样，忽略
  }
  ~~~
* 定制排序

  ~~~java
  public class TreeMapTest {
  	//定制排序
      @Test
      public void test2(){
          TreeMap map = new TreeMap(new Comparator() {
              @Override
              public int compare(Object o1, Object o2) {
                  if(o1 instanceof User && o2 instanceof User){
                      User u1 = (User)o1;
                      User u2 = (User)o2;
                      return Integer.compare(u1.getAge(),u2.getAge());
                  }
                  throw new RuntimeException("输入的类型不匹配！");
              }
          });
          User u1 = new User("Tom",23);
          User u2 = new User("Jerry",32);
          User u3 = new User("Jack",20);
          User u4 = new User("Rose",18);
  
          map.put(u1,98);
          map.put(u2,89);
          map.put(u3,76);
          map.put(u4,100);
  
          Set entrySet = map.entrySet();
          Iterator iterator1 = entrySet.iterator();
          while (iterator1.hasNext()){
              Object obj = iterator1.next();
              Map.Entry entry = (Map.Entry) obj;
              System.out.println(entry.getKey() + "---->" + entry.getValue());
          }
      }
  }
  
  public class User{
  	//和上上面代码一样，忽略
  }
  ~~~

  


#### Hashtable

```java
public void test1(){
    map = new Hashtable();
    
    //错误，key不能为NULL
    map.put(null,123);
}
```



##### Properties（了解，涉及到 JDBC ）

常用来处理配置文件。key和value都是String类型

```java
public class PropertiesTest {

    //Properties:常用来处理配置文件。key和value都是String类型
    public static void main(String[] args)  {
        FileInputStream fis = null;
        try {
            Properties pros = new Properties();

            fis = new FileInputStream("jdbc.properties");
            pros.load(fis);//加载流对应的文件

            //存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法
            String name = pros.getProperty("name");
            String password = pros.getProperty("password");

            System.out.println("name = " + name + ", password = " + password);
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if(fis != null){
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }

            }
        }

    }
}
```



## Collections 工具类

操作 Set、List 和 Map 等集合的工具类

* copy()
  void copy(List dest,List src)	将src中的内容复制到dest中
  
  ```java
  public void test2(){
      List list = new ArrayList();
      list.add(123);
      list.add(43);
      list.add(765);
      list.add(-97);
      list.add(0);
  
      //报异常：IndexOutOfBoundsException("Source does not fit in dest")
      List dest = new ArrayList();
      Collections.copy(dest,list);
      //错误
      List dest = new ArrayList(list.size());
      Collections.copy(dest,list);
      
      //正确的：
      List dest = Arrays.asList(new Object[list.size()]);
      System.out.println(dest.size());//list.size();
      Collections.copy(dest,list);
      System.out.println(dest);
  }
  ```


* synchronizedXxx()

  Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题

  ~~~java
  public void test2(){
      List list = new ArrayList();
      list.add(123);
      list.add(43);
      list.add(765);
      list.add(-97);
      list.add(0);
  
      //返回的list1即为线程安全的List
      List list1 = Collections.synchronizedList(list);
  ~~~

* 常用方法

  >reverse(List)	反转 List 中元素的顺序
  >
  >shuffle(List)	对 List 集合元素进行随机排序
  >
  >sort(List)	根据元素的自然顺序对指定 List 集合元素按升序排序
  >
  >sort(List，Comparator)	根据指定的 Comparator 产生的顺序对 List 集合元素进行排序
  >
  >swap(List，int， int)	将指定 list 集合中的 i 处元素和 j 处元素进行交换
  >
  >Object max(Collection)	根据元素的自然顺序，返回给定集合中的最大元素
  >
  >Object max(Collection，Comparator)	根据 Comparator 指定的顺序，返回给定集合中的最大元素
  >
  >Object min(Collection)
  >
  >Object min(Collection，Comparator)
  >
  >int frequency(Collection，Object)	返回指定集合中指定元素的出现次数
  >
  >boolean replaceAll(List list，Object oldVal，Object newVal)	使用新值替换 List 对象的所有旧值
  
  ~~~java
  public class CollectionsTest {
  
      @Test
      public void test1(){
          List list = new ArrayList();
          list.add(123);
          list.add(43);
          list.add(765);
          list.add(765);
          list.add(765);
          list.add(-97);
          list.add(0);
  
          System.out.println(list);
  
          Collections.reverse(list);
          Collections.shuffle(list);
          Collections.sort(list);
          Collections.swap(list,1,2);
          int frequency = Collections.frequency(list, 123);
  
          System.out.println(list);
          System.out.println(frequency);
      }
  }
  ~~~
  
  